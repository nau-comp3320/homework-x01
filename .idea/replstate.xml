<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1430452647929">{:repl-history {:ide [], :local [&quot;(defn fizzbuzz\n  \&quot;Takes a number as input and returns :fizz! if the number is divisible by 3,\n  :buzz! if the number is divisible by 5, :fizzbuzz! if divisible by both, or\n  the number itself in any other case.\&quot;\n  [n]\n  )&quot; &quot;(defn fizzbuzz\n  \&quot;Takes a number as input and returns :fizz! if the number is divisible by 3,\n  :buzz! if the number is divisible by 5, :fizzbuzz! if divisible by both, or\n  the number itself in any other case.\&quot;\n  [n]\n  (cond\n    (zero? (rem n 3)) :fizz!\n    n\n    )\n  )&quot; &quot;(defn fizzbuzz\n  \&quot;Takes a number as input and returns :fizz! if the number is divisible by 3,\n  :buzz! if the number is divisible by 5, :fizzbuzz! if divisible by both, or\n  the number itself in any other case.\&quot;\n  [n]\n  (cond\n    (zero? (rem n 3)) :fizz!\n    :default  n\n    )\n  )&quot; &quot;(defn fizzbuzz\n  \&quot;Takes a number as input and returns :fizz! if the number is divisible by 3,\n  :buzz! if the number is divisible by 5, :fizzbuzz! if divisible by both, or\n  the number itself in any other case.\&quot;\n  [n]\n  (cond\n    (zero? (rem n 15)) :buzz!\n    (zero? (rem n 3)) :fizz!\n    (zero? (rem n 5)) :buzz!\n    :default  n))&quot; &quot;(defn polygonal-seq\n  \&quot;Returns a lazy sequence of s-gonal numbers.\&quot;\n  [s]\n  ((fn seq-n [n]\n     (lazy-seq (cons (polygonal-number s n)\n                     (seq-n (inc n)))))\n    0))&quot; &quot;(defmacro infix\n  \&quot;Takes an infix mathematical expression and returns a prefix version of it.\&quot;\n  [arg1 op arg2]\n  `(~op\n     ~(if (list? arg1)\n        `(infix ~@arg1)\n        arg1)\n     ~(if (list? arg2)\n        `(infix ~@arg2)\n        arg2)))&quot; &quot;(defmacro infix\n  \&quot;Takes an infix mathematical expression and returns a prefix version of it.\&quot;\n  [arg1 op arg2]\n  `(~op\n     ~(if (list? arg1)\n        `(infix ~@arg1)\n        `arg1)\n     ~(if (list? arg2)\n        `(infix ~@arg2)\n        `arg2)))&quot; &quot;(defmacro infix\n  \&quot;Takes an infix mathematical expression and returns a prefix version of it.\&quot;\n  [arg1 op arg2]\n  `(~op\n     ~(if (list? arg1)\n        `(infix ~@arg1)\n        '~arg1)\n     ~(if (list? arg2)\n        `(infix ~@arg2)\n        '~arg2)))&quot; &quot;(defmacro infix\n  \&quot;Takes an infix mathematical expression and returns a prefix version of it.\&quot;\n  [arg1 op arg2]\n  #_(list op\n        (if (list? arg1)\n          (apply list 'homework-x01.infix/infix arg1)))\n  `(~op\n     ~(if (list? arg1)\n        `(cons infix ~@arg1)\n        '~arg1)\n     ~(if (list? arg2)\n        `(cons infix ~@arg2)\n        '~arg2)))&quot; &quot;(defmacro infix\n  \&quot;Takes an infix mathematical expression and returns a prefix version of it.\&quot;\n  [arg1 op arg2]\n  #_(list op\n        (if (list? arg1)\n          (apply list 'homework-x01.infix/infix arg1)))\n  `(~op\n     ~(if (list? arg1)\n        `(cons infix ~@arg1)\n        ~arg1)\n     ~(if (list? arg2)\n        `(cons infix ~@arg2)\n        ~arg2)))&quot; &quot;(macroexpand-1 (infix 1 + 2))&quot; &quot;(defmacro infix\n  \&quot;Takes an infix mathematical expression and returns a prefix version of it.\&quot;\n  [arg1 op arg2]\n  #_(list op\n        (if (list? arg1)\n          (apply list 'homework-x01.infix/infix arg1)))\n  `(~op\n     ~(if (list? arg1)\n        `(cons infix ~@arg1)\n        arg1)\n     ~(if (list? arg2)\n        `(cons infix ~@arg2)\n        arg2)))&quot; &quot;(defmacro infix\n  \&quot;Takes an infix mathematical expression and returns a prefix version of it.\&quot;\n  [arg1 op arg2]\n  #_(list op\n        (if (list? arg1)\n          (apply list 'homework-x01.infix/infix arg1)))\n  `(~op\n     ~(if (list? arg1)\n        `(infix ~@arg1)\n        arg1)\n     ~(if (list? arg2)\n        `(infix ~@arg2)\n        arg2)))&quot; &quot;(macroexpand-1 '(infix 1 + 2))&quot; &quot;(macroexpand-1 '(infix (3 * 5) + 2))&quot;], :remote []}}</component>
</project>